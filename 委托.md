**委托**

是一种函数指针，可以将方法作为参数传递给其他方法。是一种引用类型。

用法：*事件处理、回调函数、LINQ*

```
public delegate <return type> <delegate-name> <parameter list>
```



1、实例化委托

```c#
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         // 创建委托实例
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         // 使用委托对象调用方法
         nc1(25);
         Console.WriteLine("Value of Num: {0}", getNum());
         nc2(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
```

2、委托的多播

对相同类型的委托用“+”，“-”进行合并。

创建委托被调用时要调用的方法的调用列表，这被称为委托的 **多播（multicasting）**，也叫组播。

```c#
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         // 创建委托实例
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         // 调用多播
         nc(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
```



3、委托的用途，将方法当做参数使用

```c#
using System;
using System.IO;

namespace DelegateAppl
{
   class PrintString
   {
      static FileStream fs;
      static StreamWriter sw;
      // 委托声明
      public delegate void printString(string s);

      // 该方法打印到控制台
      public static void WriteToScreen(string str)
      {
         Console.WriteLine("The String is: {0}", str);
      }
      // 该方法打印到文件
      public static void WriteToFile(string s)
      {
         fs = new FileStream("c:\\message.txt", FileMode.Append, FileAccess.Write);
         sw = new StreamWriter(fs);
         sw.WriteLine(s);
         sw.Flush();
         sw.Close();
         fs.Close();
      }
      // 该方法把委托作为参数，并使用它调用方法
      public static void sendString(printString ps)
      {
         ps("Hello World");
      }
      static void Main(string[] args)
      {
         printString ps1 = new printString(WriteToScreen);
         printString ps2 = new printString(WriteToFile);
         sendString(ps1);
         sendString(ps2);
         Console.ReadKey();
      }
   }
}
```

显示、和隐式实例化委托

显示 new  

PrintMessage print = new PrintMessage(PrintUpperCase);

隐式：

PrintMessage print =  PrintUpperCase ;



**委托和事件**

委托常常与事件（Event）一起使用，事件是一种特殊类型的委托，用于发布和订阅机制。

在 C# 中，事件本质上就是一个封装了委托的类型，它用于响应程序中的某些操作。

```c#
public class Button
{
    // 定义一个事件
    public event EventHandler Click;

    // 引发事件的方法
    public void OnClick()
    {
        if (Click != null)
        {
            Click(this, EventArgs.Empty);  // 调用事件
        }
    }
}

public class Program
{
    public static void Main()
    {
        Button button = new Button();
        
        // 订阅事件
        button.Click += Button_Click;

        // 引发事件
        button.OnClick();  // 输出 "Button clicked!"
    }

    private static void Button_Click(object sender, EventArgs e)
    {
        Console.WriteLine("Button clicked!");
    }
}
```



**委托的类型**



